# question-web
some codes and questions of web.

#### 1. cookie是否可以被覆盖？
可以。如果重复写入同名的cookie，将会覆盖之前的cookie。<br>
如果要删除某个cookie，只需新建一个同名的cookie，并将maxAge设为0，添加到response中覆盖原来的cookie。（设置为0而不是负数，负数代表其他意义）

#### 2. js发送ajax请求原生代码？code
实例化XMLHttpRequest对象<br>
设置回调函数onreadystatechange<br>
判断readyState为4，响应完成<br>
判断http状态码<br>
启动请求open<br>
设置请求头信息setRequestHeader<br>
发送请求send

#### 3. jsonp的原理？为什么说jsonp不是真正的ajax？code
&emsp;&emsp;ajax无法跨域，但script标签的src属性可以跨域。<br>
&emsp;&emsp;调用跨域服务器上动态生成的js文件，js文件中包含客户端需要的数据。<br>
&emsp;&emsp;jsonp和ajax的目的一样，都是请求一个url，对服务器返回的数据进行处理，jQueryjsonp封装为ajax的一种形式。<br>
&emsp;&emsp;jsonp和ajax本质上是不同的，ajax的核心是通过XMLHttpRequest获取非本页面的内容，而jsonp的核心是动态加载script来调用服务器提供的js脚本。

#### 4. 强缓存和协商缓存的命中和管理？
##### 浏览器和服务器的行为：<br>
&emsp;&emsp;浏览器加载资源时，先根据资源的http header判断是否命中强缓存，如果命中则直接从浏览器缓存获取，不会发送请求到服务器。<br>
&emsp;&emsp;没有命中强缓存时，浏览器会发送一个请求到服务器，服务器通过资源的http header判断是否命中协商缓存，如果命中，服务器将请求返回，状态码为304，但不返回资源数据，而是告诉浏览器可以从缓存中获取。<br>
&emsp;&emsp;协商缓存也没有命中的时候，浏览器从服务器获取资源数据。<br>

###### 强缓存：Expires和Cache-Control<br>
&emsp;&emsp;Expires：HTTP 1.0提出的表示资源过期时间的header，描述的是绝对时间，由服务器返回。<br>
&emsp;&emsp;浏览器第一次请求一个资源，服务器返回资源的同时在response的header加上Expires。<br>
&emsp;&emsp;浏览器接收后把资源和header都保存起来。<br>
&emsp;&emsp;浏览器再次请求这个资源时，先从缓存找，找到后比较Expires和当前时间，判断是否命中缓存。<br>
&emsp;&emsp;如果没有命中，则从服务器获取该资源，同时更新Expires。<br>

&emsp;&emsp;Cache-Control：Expires比较古老，它是服务器返回的绝对时间，服务器与客户端时间相差较大时缓存管理会出现问题，比如修改客户端时间，可以影响缓存命中判断。HTTP 1.1提出了一个新的header：Cache-Control，这是一个相对时间，以秒为单位，如Cache-Control:max-age=315360000，缓存命中判断过程和Expires类似。<br>
&emsp;&emsp;Expires和Cache-Control可以同时启用，Cache-Control优先级较高。

##### 协商缓存：Last-Modified、If-Modified-Since和ETag、If-None-Match两对header
&emsp;&emsp;Last-Modified和If-Modified-Since：<br>
&emsp;&emsp;浏览器第一次请求一个资源时，服务器返回资源的同时在response的header加上Last-Modified，表示资源在服务器上的最后修改时间。<br>
&emsp;&emsp;浏览器再次请求该资源时，在request的header加上If-Modified-Since，这个值就是前面服务器返回的Last-Modified。<br>
&emsp;&emsp;服务器再次接收到请求时，比较If-Modified-Since和服务器上的资源最后修改时间，如果没有变化则返回304 Not Modified，如果有变化则返回资源和新的最后修改时间Last-Modified。<br>
&emsp;&emsp;浏览器接收到304则会从缓存中获取资源。

&emsp;&emsp;ETag和If-None-Match：<br>
&emsp;&emsp;服务器资源被修改，但没有更新最后修改时间，则Last-Modified和If-Modified-Since的判断不可靠。<br>
&emsp;&emsp;浏览器第一次请求一个资源时，服务器返回资源的同时在header加上ETag，根据资源生成的一个唯一标识字符串，资源有变化则会更新，和最后更新时间没有关系。<br>
&emsp;&emsp;浏览器再次请求该资源时在request的header加上If-None-Match，值就是ETag。<br>
&emsp;&emsp;服务器再次接收到请求时判断If-None-Match和资源生成的ETag是否相同，是则表示资源没有更新，返回304，同时会返回ETag，即使是同一个值。

##### 以下行为可能改变缓存的处理方式：<br>
&emsp;&emsp;Ctrl+F5，强制刷新，跳过强缓存和协商缓存，直接从服务器获取。<br>
&emsp;&emsp;F5，跳过强缓存，但会检查协商缓存。

#### 5. 如何在response的header中禁止浏览器缓存？
Expires：-1或0，告诉浏览器不缓存资源<br>
Cache-Control: no-cache<br>
Pragma: no-cache

#### 6. js实现异步的方法？？？
&emsp;&emsp;js语言的执行环境是单线程，一次只能执行一个任务，如果有多个任务则需要排队。<br>
&emsp;&emsp;js将任务的执行分成两种模式：同步（Synchronous）和异步（Asynchronous）。异步模式：每一个任务都有一个回调函数，一个任务执行完成后，不是执行后一个任务，而是执行回调函数，后一个任务则是不等前一个任务执行完就执行。<br>
&emsp;&emsp;实现异步的方法：<br>
&emsp;&emsp;回调函数<br>
&emsp;&emsp;事件监听：采用事件驱动模式，任务的执行不取决于代码的顺序，而是取决于某个事件是否发生。<br>
&emsp;&emsp;观察者模式<br>
&emsp;&emsp;promise对象：每一个异步任务返回一个promise对象，该对象有一个then方法，允许指定回调函数。<br>

#### 7. 浏览器输入网址后到页面展示的过程？
(1) 用户输入网址<br>
&emsp;&ensp;浏览器通过DNS获取服务器的IP地址客户端先检查本地是否有对应的IP地址，没有则请求上级DNS服务器，直到找到或到根节点。<br>
&emsp;&ensp;DNS查找IP地址的顺序：浏览器缓存、系统缓存、互联网服务提供商（ISP）的DNS缓存。<br>
(2)浏览器发送HTTP请求<br>
&emsp;&ensp;HTTP请求包括请求报头和请求主体两部分。<br>
(3) 传输层TCP传输报文<br>
&emsp;&ensp;TCP通过三次握手等方法保证传输的安全可靠。<br>
(4) 网络层IP协议查询MAC地址<br>
&emsp;&ensp;IP协议的作用是把TCP分割好的各种数据包传送给接收方，需要接收方的MAC地址，即物理地址。<br>
&emsp;&ensp;IP地址和MAC地址是一一对应的关系，IP地址可以更换，但MAC地址一般固定不变。ARP协议可以将IP地址解析成对应的MAC地址。<br>
&emsp;&ensp;当通信的双方不在一个局域网时，需要多次中转才能到达最终目标，在中转的过程中需要通过下一个中转站的MAC地址来搜索下一个中转目标。
？？？<br>
(5) 数据到达数据链路层<br>
&emsp;&ensp;找到对方的MAC地址后，就将数据发送到数据链路层传输，客户端发送结束。<br>
(6) 服务器接收数据<br>
&emsp;&ensp;服务器在数据链路层接收到数据，再向上发送到应用层，其中在传输层通过TCP协议将分段的数据包重新组成原来的HTTP请求报文。<br>
(7) 服务器响应请求<br>
&emsp;&ensp;服务器接收到请求后查找请求的资源，并返回响应报文。<br>
(8) 服务器返回响应文件<br>
&emsp;&ensp;请求成功后，服务器返回相应的资源文件（HTML文件）。<br>
(9) 浏览器页面渲染<br>
&emsp;&ensp;解析HTML构建DOM树->构建渲染树->布局渲染树->绘制渲染树<br>
&emsp;&ensp;DOM树是由HTML文件中的标签排列组成，渲染树是DOM树中加入CSS或HTML中的style样式而形成。<br>
&emsp;&ensp;浏览器还没接收到完成的HTML文件时就开始渲染页面了，在遇到外部链入的脚本标签、样式标签、图片时，会再次发送HTTP请求。收到CSS文件后会对已经渲染的页面重新渲染。

#### 8. js实现跨域的方法？？？
###### 图像Ping<br>
使用<img>标签，图片加载没有跨域限制。请求数据通过字符串形式发送，而响应可以是任何内容。<br>
只能发送get请求；<br>
浏览器无法获取响应数据；<br>
只适用于浏览器和服务器之间的单向通信。<br>
##### JSONP<br>
##### 后台代理<br>
本域的后台发送同样的http请求向其他域获取数据，再返回给前台。<br>
##### 设置document.domain<br>
只适用于主域相同而子域不同。<br>
##### 使用window.name + iframe<br>
使用HTML5新方法window.postMessage(message, targetOrigin)

#### 9. CDN缓存图片、js等静态资源？？？
内容分发网络。其基本思路是尽可能避开互联网有可能影响数据传输和稳定性的瓶颈和环境，使内容传输更稳定更快。

#### 10. 什么是缓存雪崩？如何避免？
数据未加载到缓存中，或者是缓存在同一时间大面积失效，导致获取查询请求到数据库，数据库CPU或内存负载过高。<br>

解决思路：<br>
加锁计数，或者设置合理的队列数来避免缓存失效时对数据库造成太大压力，但这样会降低系统的吞吐量。<br>
分析用户行为，让失效时间点均匀分布。<br>
缓存服务器备份。

#### 10.1. 什么是缓存穿透？如何解决？
恶意请求缓存中不存在的数据，导致所有请求落在数据库上，造成数据库压力过大而崩溃。<br>
常见的解决办法是采用布隆过滤器。将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，从而避免对底层数据库的查询压力。<br>
另外一种简单的办法：即使查询结果为空，也进行缓存，但设置较短的过期时间。

#### 11. 负载均衡实现算法？共享session共享？如何避免nginx单点故障？
随机（random）（加权随机）、轮询（round-robin）（加权轮询）、一致哈希（consistent-hash）、主备（master-slave）、最少连接（least connection）。<br>

Reids中间服务器管理session，解决不同服务器共享session的问题。<br>

nginx配置ip哈希：<br>
```
ipstream simple.com {
    ip_hash;
    server 192.168.1.1;
    server 192.168.1.2;
}
```

##### 一致哈希
将[0, 2的32次方)所有整数投射到一个圆上，然后将负载机的唯一标识（比如ip）通过hash运算得到的整数也投射到这个圆上，server-A，server-B，请求到达后，将请求的唯一标识（比如用户id）通过hash运算得到的整数也投射到这个圆上，顺时针找到第一个负载机。<br>

一致哈希解决了两个问题：<br>
散列的不变性：同一个用户的请求尽量落到同一台负载机上<br>
异常以后的分散性：某台负载机挂掉后，原来落到这台的请求尽量分散到其他负载机，对系统的冲击最小。<br>

一致哈希可用于分配cache服务，将同一用户的数据缓存到固定的服务器上，不用多台服务器缓存重复的数据，能提高缓存的利用率。但这样也有弊端，当某台服务器挂掉，请求落到其他服务器，而其他服务器上没有对应的缓存，可能会使数据库压力骤增。

##### 主备算法
尽量将请求分配到某台固定的服务器上，其他服务器做备份，固定的服务器出现问题后再切换到备份的服务器。<br>
应用：message queue消息队列，为保证时效性，尽量将所有请求都放到同一台服务器上。

##### 最少连接
根据节点的真是负载，动态的调整节点的权重。（最小响应时间，最小活跃数）<br>

Session保存到专门的服务器，多个负载机共享？？？<br>
Nginx前面再加一个F5，将请求分发给多个nginx（F5单点故障？？？）

#### 12. redirect和forward的区别？
redirect：服务器返回一个新的url，浏览器自己去请求，地址栏显示的是新的url<br>
forward：服务器直接请求资源，把响应的内容读取回来再发送给浏览器，浏览器地址栏不变。

#### 13.iframe的使用场景？
导航栏和具体功能，实现每个功能分离<br>
加载其他网站的内容<br>
ajax上传文件<br>
上传图片时，不使用flash实现无刷新？？？<br>
跨域的时候作用中间人？？？

#### 14. TCP和UDP的区别？FTP而为什么是基于TCP的？？？迅雷为什么是基于UDP的？？？
项 | TCP | UDP
-|-|-
连接 | 面向连接 | 无连接
可靠性 | 可靠，无差错不丢失 | 尽最大努力交付，不保证可靠
点对点 | 每一条都是点对点 | 支持一对一，一对多，多对一，多对多
首部开销 | 小 | 大

#### 15. webSocket的原理？Java服务端的实现？？？
HTML5提供的一种浏览器与服务器进行全双工通讯的应用层协议，基于TCP传输协议，复用了HTTP的握手通道。<br>
客户端发起协议升级请求，使用HTTP报文格式，只支持GET。<br>
持久化的协议。<br>
```
GET / HTTP/1.1
Host:  localhost:8080
Origin:  http://127.0.0.1:3000
Connection:  Upgrade                   # 需要升级协议
Upgrade:  websocket                    # 需要升级到websocket协议
Sec-WebSocket-Key:  x3JJHMbDL1EhXDw==  # 对应响应的Sec-WebSocket-Accept，防护
Sec-WebSocket-Version:  13
Sec-WebSocket-Protocol:  chat, superchat
```
服务端响应协议升级，状态码101表示切换协议。<br>
```
HTTP/1.1 101 Switching Protocols
Connection:  Upgrade
Upgrade:  websocket
Sec-WebSocket-Accept:  OyNC7bP8dTKb4PTU=
```
客户端和服务端通信的最小单位是帧，有一个或多个帧组成一条完成的消息，发送消息时将消息切割成多个帧，接收消息时将多个帧拼接成消息。
<br>
为了保持客户端和服务端的实时双向通信，需要保持TCP连接不断开，采用心跳来实现。<br>
发送方->接收方：ping<br>
接收方->发送方：pong<br>

传统的HTTP协议实现服务端实时推送的方式有ajax轮询和long poll。<br>
ajax轮询：每隔几秒就发一个请求<br>
long poll：阻塞模型，客户端发起请求后，如果没有消息，就一直不返回response。

#### 16. 正向代理和反向代理？
正向代理：<br>
A想访问C，但无法直接访问，那么A访问B，B再访问C，那么A就能访问C，但C并不知道被谁访问。比如google无法访问，但搭建在国外的B可以访问，那么让他去请求google再把内容返回给A。<br>

反向代理：<br>
A访问baidu，baidu背后有很多台服务器，A并不知道是哪台提供的服务，只需要知道代理服务器是baidu就好了，反向代理服务器会将请求发给真实的服务器，主要是实现负载均衡。

#### 17. sessionStorage、localStorage、cookie的区别？localStorage的存储？code
项 | sessionStorage | localStorage | cookie
-|-|-|-
相同点 | / | 都是浏览器端的数据存储，同源 | /
传递 | / | / | 在同源的http请求中携带，有路径的概念，大小不超过4k
有效期 | 浏览器关闭窗口前有效 | 一直有效 | 在设置的有效期前有效
不同的浏览器窗口 | 不共享 | 共享 | 共享
事件机制 | 支持 | 支持 | 不支持

#### 18. 同源策略指的是什么？
同源是指协议、域名、端口相同。<br>
同源策略是指浏览器对不同源的脚本或文本的访问进行限制，比如源a的js不能操作源b的元素属性。<br>
限制主要为：cookie和localStorage的读取、DOM的获取、发送ajax请求。

#### 19. 为什么js是阻塞加载的？
浏览器需要一个稳定的DOM结构，而js很可能会改变DOM结构，为了防止渲染好的DOM树又被js修改，会阻塞其他js文件的下载和呈现。

#### 20. URI和URL的区别？？？
URI是统一资源标识符，uniform resource identifier，用来唯一标识一个资源。<br>
Web上的每个资源都是有URI来唯一标识的。URI一般包括三个部分：<br>
(1) 访问资源的命名机制<br>
(2) 存放资源的主机名<br>
(3) 资源自身的名称，由路径表示，着重强调与资源。<br>

URL是统一资源定位器，uniform resource locator，是一种具体的URI，即URL可以用来标识一个资源，还指明了如何定位这个资源。URL一般由三部分组成：<br>
(1) 协议（服务方式）<br>
(2) 存有该资源的主机IP地址<br>
(3) 资源的具体地址，如目录和文件名等。<br>

URI以一种抽象的，高层次的概念定义统一资源标识符，URL是具体的资源标识方式。

#### 21. cookie的缺点？
大小和数目受限制。浏览器限制一个域的cookie数目，且一个cookie的大小不能超过4kb。<br>
存在安全性问题，易被拦截。<br>
需要指定域，不能跨域。<br>
浪费带宽，每次请求都需要带上<br>
有的移动端浏览器不支持或禁用cookie<br>
有些状态不能保持在客户端。比如为了防止表单重复提交，需要在服务端保存一个计数器，如果保存在客户端，起不到任何作用。

#### 22.常见的web攻击有哪些？
**跨站脚本攻击（XSS, Cross Site Script）**<br>
向网页中注入恶意脚本，用户访问网页时在用户浏览器执行。<br>
反射型：诱使用户点击含有恶意脚本的链接。<br>
持久型：将脚本提交到网站的数据库中，用户访问时从数据库加载到页面中执行。<br>
防范：对危险字符进行HTTP转义；使用HTTPOnly，cookie对浏览器不可见。

**分布式拒绝服务（DDOS）**

**跨站请求伪造攻击（CSRF, Cross Site Request Forgery）**<br>
通过跨站的请求，利用浏览器的cookie或服务器的session窃取用户身份，以合法	的身份进行非法的操作。<br>
防范：在表单中添加token令牌；启用验证码；检查请求头中的referer（表明请求	来自哪里）

**sql注入攻击**

#### 23. Nginx简介？Nginx的master和worker进程分别是什么？如何实现热部署？如何实现高并发？
Nginx是一款轻量级的web服务器/反向代理服务器及电子邮件代理服务器。<br>
Nginx主要提供反向代理、负载均衡、动静分离（静态资源服务）等服务。<br>
Nginx负载均衡支持weight轮询、ip_hash、fair、url_hash四种算法。<br>
动静分离是让动态网站动态网页根据规则把不变的资源和常变的资源分开，对静态资源做缓存，即网站静态化处理。<br>

Nginx的优点：<br>
(1) 高并发、高性能（其他web服务器不具备）<br>
(2) 占用内存少，启动极快
(3) 可扩展性好（模块化设计，支持第三方插件）<br>
(4) 高可靠性（持续不间断运行数年）<br>
(5) 热部署（可以在不停止服务的情况下升级Nginx）<br>
(6) BSD许可证（可以下载源码修改）<br>

Nginx的四个主要组成部分：<br>
Nginx 二进制可执行文件，由各模块源码编译出一个文件<br>
Nginx.conf 配置文件<br>
access.log 访问日志<br>
error.log 错误日志

master进程的作用是读取并验证配置文件nginx.conf；管理worker进程。<br>
每一个worker进程都维护一个线程（避免线程切换），处理连接和请求；worker进程的个数由配置文件决定，一般和CPU个数相关，有利于进程切换。<br>

所谓热部署，是指修改配置文件nginx.conf，不需要关闭nginx，不需要中断请求，就能让配置文件生效。<br>
修改配置文件后，重新生成新的worker进程，以新的配置处理请求，新的请求提交给新的worker进程，旧的worker进程等处理完请求后结束掉即可。

采用Linux的epoll模型，epoll模型基于事件驱动机制，监控多个事件是否准备完毕，如果完毕，那么放入epoll队列中，这个过程是异步的，worker进程只需要从epoll队列取出事件处理即可。

#### 24. 什么是微服务？有哪些框架？

#### 25. TCP/IP协议？
TCP协议：面向连接的、可靠的、基于字节流的传输层通信协议，负责数据的可靠性传输。<br>
IP协议：用于报文交换网络的一种面向数据的协议，负责给每台网络设备一个网络地址，保证数据传输到正确的目的地。

#### 26. 短链接（网址）设计？？？question-java-web 10
通过发号策略，对每一个长地址发一个号，小型系统可以直接用MySQL的自增索引，大型应用可以采用分布式key-value系统做发号器，将得到的10进制的号转化为62进制。

对于同一个长地址，多次请求会生成不同的短地址，可以采用key-value（key是长地址，value是短地址）存储最近生成的记录，采用过期淘汰机制。

发号器可以拆分成多个，比如拆成两个，生成单双号，拆成10个，生成0~9。

跳转用301还是302？
301是永久重定向，302是临时重定向。301比较符合HTTP语义，但无法统计到短地址的点击次数，选用302能有助于数据分析。

#### 27. 集群服务器（分布式系统）如何同步session？？？
(1) session复制
多台服务器之间相互复制，每一台服务器都保存了所有的sessio。
仅适用于小型集群。
(2) session绑定
利用负载均衡的客户端地址hash算法，同一个客户端的请求转发到同一台服务器上。
某一台服务器故障会导致这部分的session丢失。
(3) 利用cookie记录session
将session加密后存储在cookie中，接收到请求时从cookie中获取session进行解密。
有被破解的危险；
用户可能禁用cookie。
(4) session服务器
统一管理session。
分布式缓存？？？Redis？？？

#### 28. 什么是URL重写？
URL重写是一个截取传入web请求并自动将请求重定向到其他URL的过程。<br>
URL重写的优点在于：<br>
(1) 缩短URL，隐藏实际路径提高安全性<br>
(2) 便于用户记忆和输入<br>
(3) 便于被搜索引擎收录，大部分搜索引擎对于动态页面的抓取还比较弱

Nginx、Apache、Tomcat都可以配置实现URL重写。

#### 29. 会话跟踪技术有哪些？
session<br>
cookie<br>
表单隐藏域？？？<br>
重写url？？？

#### 30. 什么是分布式事务？？？
设计到操作多个数据库的事务，保证分布式系统的数据一致性。<br>
处理的关键在于有一种机制可以知道事务在任何地方所做的所有操作，提交或回滚的决定必须产生统一的结果，都提交或都回滚。<br>
两阶段提交协议。准备阶段（投票）和提交阶段（执行）<br>
三阶段提交。<br>
JTA（Java Transaction API）：分布式事务

#### 31. cookie和token的区别？？？

#### 32. 消息中间件有哪些优点？
**RabbitMQ**：支撑高并发、高吞吐量、性能很高、有完善的后台管理界面，另外还支持集群化、高可用部署架构、消息高可靠支持，功能比较完善；社区活跃、版本迭代频繁。<br>
缺点：基于erlang开发，难分析源码或二次开发。<br>
**RocketMQ**：阿里开源的，经过阿里的生产环境的超高并发、高吞吐量的考验，性能卓越，支持分布式事务等特殊场景。<br>
基于Java语言开发，适合阅读源码，进行二次开发。<br>
**ActiveMQ**：老牌的消息中间件<br>
**Kafka**：功能比较少，优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景设计。因此在大数据领域中配合实时计算技术（Spark Streaming, Storm, Flink）使用的比较多。

优点：<br>
系统解耦<br>
异步调用<br>
流量削峰

#### 33. 系统架构引入消息中间件的缺点？
系统可用性降低<br>
系统稳定性降低<br>
分布式一致性问题

#### 34. 什么是URL编码和URL解码？
URL编码是把URL中的空格和其他特殊字符替换成对应的十六进制表示，反之则是解
码。

#### 35. 常用的加密算法？
对称加密：DES、AES<br>
非对称加密：RSA、DSA<br>
单向散列函数加密：MD5、SHA<br>

#### 36. 什么是session钝化？
正常情况下，session是存放在服务器的内存当中的，用户较多时，服务器的开销会很大，需要把未使用到的session对象序列化到文件系统中，需要用到的时候再反序列化到内存中。

#### 37. 什么是XSS攻击和CSRF攻击？
XSS（Cross Site Script）跨站脚本，向网页中注入恶意脚本，用户浏览网页时在用户浏览器中执行。反射型：诱使用户点击含有恶意脚本的链接；持久型：将脚本提交到网站的数据库中，用户访问时从数据库加载到页面中执行。<br>
防范：<br>
(1) 对危险字符进行http转义<br>
(2) 使用HttpOnly，cookie对浏览器不可见。<br>

CSRF（Cross Site Request Forgery）跨站请求伪造，通过跨站的请求，以合法的身份进行非法的操作。原理是利用浏览器的cookie或服务器的session窃取用户身份。<br>
防范：<br>
(1) 在表单中添加token令牌<br>
(2) 验证码<br>
(3) 检查请求头中的Referer，Referer是http请求头的一个属性，表明请求来自哪里。

#### 38. 分布式、高并发、多线程的区别？
分布式是一个概念，是为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段，包括分布式文件系统、分布式缓存、分布式数据库、分布式计算。<br>
分布式的实现有两种方式：<br>
(1) 水平扩展：通过添加服务器的方式，将流量分到多个服务器上<br>
(2) 垂直拆分：将业务拆分到不同的服务器上<br>

高并发从业务角度去描述系统的能力，要解决的问题是访问量，可以通过分布式的技术去解决，此外还有其他优化手段：缓存系统、CDN、多线程。<br>

多线程是指从软件或硬件上实现多个线程并发执行的技术，更多的是解决CPU调度多个进程的问题，从而让这些进程看上去是同时执行的。

#### 39. 网络分层？
四层分法：应用层、运输层、网络层、网络接口层
七层分法：应用层、表示层、会话层、运输层、网络层、数据链路层、网络层




























#### 100.question 100

# question-architecture-mq
some questions and answers for Message Queue, like RabbitMQ, ActiveMQ, Kafka and so on.

#### 1. 消息中间件有哪些优点？
优点：<br>
- 系统解耦<br>
消息队列要解决的最本质问题。
- 异步调用<br>
提高系统性能
- 流量削峰
- 最终一致性<br>
不是消息队列的必备特性，但是可以通过消息队列来实现
- 广播

**RabbitMQ**：支撑高并发、高吞吐量、性能很高、有完善的后台管理界面，另外还支持集群化、高可用部署架构、消息高可靠支持，功能比较完善；社区活跃、版本迭代频繁。<br>
缺点：基于erlang开发，难分析源码或二次开发。<br>
**RocketMQ**：阿里开源的，经过阿里的生产环境的超高并发、高吞吐量的考验，性能卓越，支持分布式事务等特殊场景。<br>
基于Java语言开发，适合阅读源码，进行二次开发。<br>
**ActiveMQ**：老牌的消息中间件，比较成熟，但性能较差，迭代慢<br>
**Kafka**：功能比较少，优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景设计。因此在大数据领域中配合实时计算技术（Spark Streaming, Storm, Flink）使用的比较多。

特性 | ActiveMQ | RabbitMQ | RocketMQ | Kafka
-|-|-|-|-
开发语言 | Java | Erlang | Java | Scala
单机吞吐量 | 万级 | 万级 | 十万级 | 十万级
时效性 | ms级 | us级 | ms级 | ms级以内
可用性 | 高（主从架构） | 高（主从架构） | 非常高（分布式架构） | 非常高（分布式架构）
功能特性 | 成熟的产品，在很多公司得到应用；<br>有较多的文档；<br>各种协议支持较好 | 基于erlang开发，并发能力很强，性能极好，延时很低；<br>管理界面比较丰富 | MQ功能比较完备，扩展性好 | 只支持主要的MQ功能；为大数据准备，在大数据领域应用较广

#### 2. 系统架构引入消息中间件的缺点？
- 系统可用性降低<br>
解决：集群
- 系统稳定性降低<br>
重复消费：全局唯一ID<br>
消息丢失：生产者丢失（MQ事务回滚）、消费者丢失（修改自动确认为手动确认）<br>
消息顺序正确性<br>
- 分布式一致性问题（消息没有被消费）

#### 3. 两种消息队列协议？
项 | JMS (Java Message Service) | AMQP (Advanced Message Queuing Protocol)
-| - | -
定义 | Java API | 协议
跨语言 | 否 | 是
跨平台 | 否 | 是
支持消息模型 | 两种消息模型：<br>(1)Peer-to-Peer<br>(2)Pub/sub | 五种消息模型：
支持消息类型 | 多种消息类型：<br>StreamMessage<br>MapMessage<br>TextMessage<br>ObjectMessage<br>BytesMessage | 二进制

AMQP协议定义了publisher、consumer、exchange、queue<br>
RabbitMQ是AMQP协议的一种实现。

#### 4. 如何确保消息正确的发送至RabbitMQ？如何确保消费者接收消费了消息？
发送方确认模式：<br>
将信道设置为确认模式（发送方确认模式），所有在信道上发布的消息都会指派一个唯一ID。消息被投递到目的队列后，或者消息被写入磁盘后，信道会发送一个确认（包含消息唯一ID）给生产者。如果RabbitMQ内部发生错误导致消息丢失，会发送一条nack（not acknowledged，未确认）消息。<br>
发送方确认模式是异步的，生产者在等待确认的同时，可以继续发送消息。当确认消息到达生产者时，生产者的回调方法被触发来处理确认消息。<br>

接收方确认机制：<br>
消费者接收每一条消息后都需要进行确认，只有消费者确认了消息，RabbitMQ才能安全的把消息从队列中删除。<br>
这里没有用到超时机制，RabbitMQ仅通过consumer的连接中断来确认是否需要重新发送消息，只要连接不中断，消费者有足够长的时间来处理消息。

#### 5. RabbitMQ如何确保消息不丢失？
通过消息持久化，前提是队列必须持久化。<br>
将消息写入磁盘的一个持久化日志文件，当发布一条持久性消息到持久交换器时，RabbitMQ会在消息提交到日志后才发送响应，确保持久性消息能从服务重启中恢复。<br>
消费者从持久队列中消费了一条持久化消息，RabbitMQ会在持久化日志中把这条消息标记为等待垃圾回收。<br>
如果持久化消息在被消费之前RabbitMQ重启，RabbitMQ会自动重建交换器和队列，并重新发布持久化日志文件中的消息到合适的队列。<br>

#### 6. 如何保证消息的有序性？
(1) 消费者内部用队列实现<br>
(2) 对消息进行编号，消费者根据编号判断<br>
(3) 业务逻辑中自己实现？<br>

#### 7. 如何实现消息的重发？
消息重发是指消费者在消费异常时，消费者将消息重新放入队列下次处理。<br>
超过重试次数后会放入一个特殊队列Dead Letter Queue中。

#### 8. 如何避免消息重复消费或重复投递？如何实现幂等？
生产消息时，MQ内部针对每条生产者发送的消息生成一个inner-msg-id，作为去重的依据，避免重复的消息进入队列。<br>
消费消息时，要求消息体中必须有一个全局的唯一ID，作为去重的依据，避免同一条消息被重复消费。<br>

(1) 消息编号<br>
(2) 保存消费记录

#### 9. 如何利用消息队列实现最终一致性？

#### 10. RabbitMQ消息基于什么传输？
TCP连接的创建和销毁的代价较大，且并发数受系统资源限制，会造成性能瓶颈。<br>
RabbitMQ使用信道的方式来传输数据。信道是建立在真实TCP连接内的虚拟连接，且每条TCP连接上的信道数量不受限制。

#### 11. RabbitMQ的基本概念？
##### 生产者
生产者发送一个消息，需要指定交换器名称、路由键、消息内容、额外参数<br>
(1) 交换器名称：指定消息要发送到哪个交换器<br>
(2) 路由键：用于交换器如何路由该消息到队列<br>
(3) 消息内容：字节流<br>
(4) 额外参数：是否需要持久化，contentType，存活时间<br>

##### 消费者

##### 交换器
消息路由，决定如何将消息传递到队列或其他交换器。<br>
一个交换器的组成：名称、路由方式。<br>
四种路由方式：直接路由direct、广播路由fanout、话题路由topic、header<br>
默认交换器：名称为空字符串，路由方式为直接路由。<br>
定时交换器时可以指定候补交换器，指定是否持久化、是否自动删除。<br>

##### 队列
存放消息的容器。<br>
消息存活时间，取决于队列设定和消息自身设定的最小值。<br>
队列和消息都可以持久化。<br>
队列可以设定最大长度和最大容量，超出时可舍弃即将入队的消息或最早的消息。<br>
队列可以设定消息优先级。

##### 路由绑定
将一个队列绑定/解绑到另一个交换器。<br>
将一个交换器绑定/解绑到另一个交换器。

##### 死信
(1) 被消费者拒绝<br>
(2) 队列长度超出限制后被舍弃<br>
(3) 消息超时<br>
队列可以设置消息成为死信后的处理方式：<br>
x-dead-letter-exchange：死信投入到交换器<br>
x-dead-letter-routing-key：死信投入到死信交换器的路由键

生产消息确认机制<br>
中间件通知生产者消息已被记录，是一个异步确认过程<br>

事务性消息发布<br>
与消息确认互斥<br>

消费者两种获取消息的模式：push、pull<br>

消费消息确认机制：autoAck<br>
true：消息在接收时直接自动返回确认<br>
false：程序在消息处理完后手动返回确认<br>

push：<br>
消费者有未确认的消息时，队列不会再推送消息给消费者<br>
消费者可以设置perfetch参数，设置自身同时处理消息的最大数量。

多个消费者订阅同一个队列，以轮询的方式发送消息给消费者。<br>

消息确认机制和事务性消息发布会降低吞吐量。<br>

exchange、queue、message均可以持久化到磁盘。<br>

##### 集群
每一个节点都保存了所有的exchange和queue。<br>
每个队列的消息仅保存在一个节点（普通模式）。<br>
可以为节点上的队列设置镜像（镜像模式），对于每个队列来说，其中一个节点上的是master，其他的是slave

#### 12. RabbitMQ的集群？
**单一模式**：<br>
单机，不做集群<br>
**普通集群模式**：<br>
默认的模式。<br>
对于queue来说，消息实体只存在于一个节点，多个节点保存相同的元数据，即队列结构。<br>
消息实体进入节点1，而consumer从节点2消费时，RabbitMQ会在节点1和节点2之间进行临时的消息传输，把节点1的消息实体取出并经过节点2发送给consumer，所以consumer应尽量连接所有节点。<br>
节点1故障后，如果做了消息持久化，那么等节点1恢复后可以继续消费；如果没有持久化，则消息会丢失。<br>
**镜像集群模式**：<br>
把队列做成镜像队列，存在于多个节点。<br>
和普通模式的不同之处：消息实体会主动在镜像节点间同步。<br>
缺点：降低系统性能；同步会消耗集群内部的网络带宽。<br>
适合在对可靠性要求较高的场景中使用。<br>

#### 13. 消息如何延迟消费？
RocketMQ: 支持定时消息，可以指定延迟的级别，各个级别可以在配置文件broker.conf中配置
RabbitMQ: 利用Time-To-Live Extensions和Dead Letter Exchange，设置过期时间为需要延迟的时间，过期后通过Dead Letter Exchange路由到其他队列，被消费。

#### 14. RocketMQ

##### 优势
- 支持事务性消息
- 支持多个系统之间的数据最终一致性
- 支持指定次数和时间间隔的失败消息重发
- 支持consumer端tag过滤，减少不必要的网络传输
- 支持重复消费

##### Nameserver和Broker
Nameserver负责维护producer和consumer的配置信息、状态信息，并且协调各个角色的协同执行。<br>
通过Nameserver各个角色可以了解到集群的整体信息，并且他们会定期向nameserver上报状态。<br>

为什么不用Zookeeper？<br>
Zookeeper是Apache旗下用于分布式服务协调的开源软件，并且拥有选举机制，能够在master宕机时从slave中通过选举机制选出一个slave变成master。<br>
但是在nameserver的设计中，masterBroker中没有一台拥有全部的topic信息，消息分布平均，失去选举机制的意义。<br>
其次，nameserver仅仅被用于存储集群的配置信息、元数据信息，不需要太复杂的功能，所以放弃重量级的Zookeeper，选择轻量级的nameserver。





#### 100. question 100

# question-architecture
some questions and answers for architecture.

#### 1. CDN缓存图片、js等静态资源？？？
内容分发网络。其基本思路是尽可能避开互联网有可能影响数据传输和稳定性的瓶颈和环境，使内容传输更稳定更快。

#### 2. 什么是缓存雪崩？如何避免？
数据未加载到缓存中，或者是缓存在同一时间大面积失效，导致获取查询请求到数据库，数据库CPU或内存负载过高。<br>

解决思路：<br>
加锁计数，或者设置合理的队列数来避免缓存失效时对数据库造成太大压力，但这样会降低系统的吞吐量。<br>
分析用户行为，让失效时间点均匀分布。<br>
缓存服务器备份。

#### 3. 什么是缓存穿透？如何解决？布隆过滤器原理？？？
恶意请求缓存中不存在的数据，导致所有请求落在数据库上，造成数据库压力过大而崩溃。<br>
常见的解决办法是采用布隆过滤器。将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，从而避免对底层数据库的查询压力。<br>
另外一种简单的办法：即使查询结果为空，也进行缓存，但设置较短的过期时间。

#### 4. 什么是缓存击穿？如何解决？
热点数据过期瞬间，解决方式有两种：<br>
(1) 互斥锁<br>
缓存过期后，程序去更新缓存前，先获取锁，获取到锁的线程才能更新，没有获取到锁的线程休眠一段时间后再次尝试获取缓存。同一时刻只有一个线程去读数据库，避免大量数据库请求对数据库的冲击。<br>
比如Redis，可以用SETNX命令对key加锁。
```java
public String get(String key) {
    String value = redis.get(key);
    if (value == null) { // 缓存过期
        if (redis.getnx(key_mutex, 1, 1 ** 60) == 1) {
            value = db.get(key);
            redis.set(key, value, expire_time);
            redis.del(key_mutex);
        } else { // 没有获取到锁，休眠后获取缓存
            sleep(50);
            redis.get(value);
        }
    } else {
        return value;
    }
}
```
(2) 永不过期

#### 4. 如何提高缓存的命中率？
缓存的命中率越高，说明缓存的效益越高，应用的性能越好，抗并发的能力越强。<br>
(1) 缓存的粒度越小，命中率越高<br>
(2) 数据变化时，直接更新缓存，比移除缓存命中率更高<br>
(3) 合理利用有限的容量，减少失效和淘汰（大多数采用LRU算法）<br>
(4) 缓存预加载<br>

#### 5. 负载均衡实现算法？
随机（random）（加权随机）、轮询（round-robin）（加权轮询）、一致哈希（consistent-hash）、主备（master-slave）、最少连接（least connection）。<br>

Redis中间服务器管理session，解决不同服务器共享session的问题。<br>

nginx配置ip哈希：<br>
```
ipstream simple.com {
    ip_hash;
    server 192.168.1.1;
    server 192.168.1.2;
}
```
##### 一致哈希
将[0, 2的32次方)所有整数投射到一个圆上，然后将负载机的唯一标识（比如ip）通过hash运算得到的整数也投射到这个圆上，server-A，server-B，请求到达后，将请求的唯一标识（比如用户id）通过hash运算得到的整数也投射到这个圆上，顺时针找到第一个负载机。<br>

一致哈希解决了两个问题：<br>
散列的不变性：同一个用户的请求尽量落到同一台负载机上<br>
异常以后的分散性：某台负载机挂掉后，原来落到这台的请求尽量分散到其他负载机，对系统的冲击最小。<br>

一致哈希可用于分配cache服务，将同一用户的数据缓存到固定的服务器上，不用多台服务器缓存重复的数据，能提高缓存的利用率。但这样也有弊端，当某台服务器挂掉，请求落到其他服务器，而其他服务器上没有对应的缓存，可能会使数据库压力骤增。

具有较好的容错性和扩展性。
改进：虚拟节点。服务节点较少时，可能出现分布不均匀，可以对每个节点都计算一个虚拟节点。

##### 主备算法
尽量将请求分配到某台固定的服务器上，其他服务器做备份，固定的服务器出现问题后再切换到备份的服务器。<br>
应用：message queue消息队列，为保证时效性，尽量将所有请求都放到同一台服务器上。

##### 最少连接
根据节点的真是负载，动态的调整节点的权重。（最小响应时间，最小活跃数）<br>

#### 6. 负载均衡分类？
- 二层负载均衡<br>
负载均衡服务器对外提供一个VIP（虚IP），集群中不同机器使用相同IP，不同MAC。负载均衡服务器接收到请求后，根据改写报文的目标MAC的方式将请求转发到目标服务器。
- 三层负载均衡<br>
和二层类似，负载均衡服务器对提供一个虚IP，但集群中不同机器使用不同IP。接收到请求后，根据不同的负载均衡算法，通过IP将不同的请求转发的目标服务器。
- 四层负载均衡<br>
工作在OSI模型的传输层，只有TCP/UDP协议，这两种协议包含源IP、目标IP、源端口、目标端口。接收到请求后，通过修改数据包的地址（IP+端口号）将流量转发到应用服务器。
- 七层负载均衡<br>
工作在OSI模型的应用层，有较多协议，常用HTTP，Redius、DNS等。可根据七层的URL、浏览器类别、语言决定是否进行负载均衡。

#### 7. 常用负载均衡工具？
LVS，Nginx，HaProxy<br>
- LVS（Linux Vitrual Server）<br>
Linux虚拟服务器，通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器集群。<br>
LVS主要用来做四层负载均衡，服务器集群系统由三部分组成：最前端的负载均衡层（Load Balancer）、中间的服务器群组层，用Server Array表示、最底层的数据共享存储层，用Shared Storage表示。<br>
在用户看来所有的应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务。
- Nginx<br>
主要用来做七层负载均衡。
- HaProxy<br>
提供高可用、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，是免费、快速、可靠的解决方案，特别适用于负载大的web站点。

#### 8. 正向代理和反向代理？
正向代理：<br>
A想访问C，但无法直接访问，那么A访问B，B再访问C，那么A就能访问C，但C并不知道被谁访问。比如google无法访问，但搭建在国外的B可以访问，那么让他去请求google再把内容返回给A。<br>

反向代理：<br>
A访问baidu，baidu背后有很多台服务器，A并不知道是哪台提供的服务，只需要知道代理服务器是baidu就好了，反向代理服务器会将请求发给真实的服务器，主要是实现负载均衡。

#### 8. 短链接（网址）设计？？？question-java-web 10
通过发号策略，对每一个长地址发一个号，小型系统可以直接用MySQL的自增索引，大型应用可以采用分布式key-value系统做发号器，将得到的10进制的号转化为62进制。

对于同一个长地址，多次请求会生成不同的短地址，可以采用key-value（key是长地址，value是短地址）存储最近生成的记录，采用过期淘汰机制。

发号器可以拆分成多个，比如拆成两个，生成单双号，拆成10个，生成0~9。

跳转用301还是302？
301是永久重定向，302是临时重定向。301比较符合HTTP语义，但无法统计到短地址的点击次数，选用302能有助于数据分析。

#### 10. 集群服务器（分布式系统）如何同步session？？？
(1) session复制<br>
多台服务器之间相互复制，每一台服务器都保存了所有的session。<br>
仅适用于小型集群。<br>
基于Resin/Tomcat，web容器本身的session复制机制<br>
(2) session绑定<br>
利用负载均衡的客户端地址hash算法，同一个客户端的请求转发到同一台服务器上。<br>
某一台服务器故障会导致这部分的session丢失。<br>
(3) 利用cookie记录session<br>
将session加密后存储在cookie中，接收到请求时从cookie中获取session进行解密。<br>
有被破解的危险；<br>
用户可能禁用cookie。<br>
(4) session服务器<br>
统一管理session。<br>
基于数据库的session共享；<br>
基于OsCache/Redis/Memcached进行session共享

#### 11. 什么是分布式事务？？？
涉及到操作多个数据库的事务，保证分布式系统的数据一致性。<br>
处理的关键在于有一种机制可以知道事务在任何地方所做的所有操作，提交或回滚的决定必须产生统一的结果，都提交或都回滚。<br>

两阶段提交（强一致性）：备阶段（投票）、提交阶段（执行）<br>
三阶段提交（强一致性）：<br>
消息中间件（最终一致性）：<br>

JTA（Java Transaction API）：分布式事务

注：<br>
强一致性：数据更新后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。<br>
弱一致性：数据更新后，不承诺可以立即读到最新写入的值，也不承诺多久之后可以读到。<br>
最终一致性：弱一致性的一种形式，保证最终会返回上一次更新操作的值。<br>

#### 12. 分布式事务解决方案？
两阶段提交（2PC）
第一阶段：事务协调器要求每个涉及到事务的数据库预提交（precommit）此操作，并反映是否可以提交
第二阶段：事务协调器要求每个数据库提交数据
如果有任何一个数据库否决此次提交，则所有数据库都回滚。
牺牲了一部分可用性来换取一致性。
优点：尽量保证了数据的强一致性，适合对强一致性要求高的关键领域
缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发场景

补偿事务（TCC）
针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作，分为三个阶段：
try阶段：对业务系统做检测及资源预留
confirm阶段：对业务系统做确认提交，try阶段执行成功并开始执行confirm阶段时，默认confirm阶段不会出错，即try成功，confirm一定成功
cancel阶段：业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放
优点：和2PC相比，实现以及流程相对简单，但数据的一致性比2PC要差一些
缺点：应用层的补偿，需要写补偿的代码，在一些场景中可能不好定义

本地消息表
MQ事务消息
Sagas事务模型

#### 12. 分布式、高并发、多线程的区别？
分布式是一个概念，是为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段，包括分布式文件系统、分布式缓存、分布式数据库、分布式计算。<br>
分布式的实现有两种方式：<br>
(1) 水平扩展：通过添加服务器的方式，将流量分到多个服务器上<br>
(2) 垂直拆分：将业务拆分到不同的服务器上<br>

高并发从业务角度去描述系统的能力，要解决的问题是访问量，可以通过分布式的技术去解决，此外还有其他优化手段：缓存系统、CDN、多线程。<br>

多线程是指从软件或硬件上实现多个线程并发执行的技术，更多的是解决CPU调度多个进程的问题，从而让这些进程看上去是同时执行的。

#### 13. 分布式架构设计中的CAP理论？
- 数据一致性（Consistency）：所有节点在同一时间具有相同的数据
- 可用性（Availability）：保证对于每个请求成功或失败都有响应
- 分区容错性（Partition Tolerance）：系统中信息的丢失或失败不影响系统的运行

CAP定理：在一个分布式系统构建中，不可能同时满足一致性、可用性和分区容错性三个需求，最多只能同时满足两个<br>

- 强一致性：ACID
- 分布式一致性：CAP
- 弱一致性（最终一致性）：BASE

#### 14. 分布式BASE理论？
部分业务可以容忍一定程度的延迟一致，为了兼顾效率，发展出最终一致性理论BASE。<br>
BASE理论是对CAP中一致性和可用性权衡的结果。<br>
- 基本可用（Basically Available）：分布式系统在故障的时候，允许损失部分可用性，保证核心可用
- 软状态（Soft State）：系统存在中间状态，允许不同节点间副本同步的延迟
- 最终一致性（Eventual Consistency）：所有副本经过一定时间后，最终能够达到一致的状态

#### 15. 分布式系统全局ID生成方案？
(1) UUID<br>
优点：性能高<br>
缺点：无法递增；占用空间大；不可读<br>
(2) twitter的snowflake算法<br>
优点：简单高效；能递增<br>
缺点：依赖机器的时钟，时钟回拨会生成重复的ID；分布式环境时钟不同步导致不是递增<br>
(3) 数据库自增ID<br>
优点：简单，天然递增<br>
缺点：数据迁移、分离、合并困难；性能瓶颈；单点故障<br>
(4) Redis<br>
优点：性能优于数据库<br>
缺点：需要编码和配置，增加系统复杂度<br>
(5) zookeeper<br>
比较少用

#### 16. 分布式锁？
分布式锁的要求：
- 互斥性
- 可重入性
- 不会死锁
- 阻塞锁
- 高可用

三种实现方式：
- （乐观锁）基于版本号和CAS实现，与存放版本号的存储无关
- （悲观锁）数据库锁
数据库表记录锁住的方法或资源
- （悲观锁）基于Redis的分布式锁
setnx函数<br>
轮询机制，锁释放后可能多个竞争，某些任务可能饿死
- （悲观锁）基于ZooKeeper的分布式锁<br>
基于临时有序节点，客户端对资源加锁时，在zookeeper上与该资源对应的指定节点的目录下，生成一个唯一的瞬时有序节点。有序节点中序号最小的一个获得锁。释放锁时删除节点。<br>
监听机制

#### 17. 领域驱动设计？充血模型？贫血模型？
Domain-Driven Design，简称DDD。<br>
领域模型对象只是用来存储应用的数据，使用了贫血模型这种反模式。<br>
失血模型：模型仅包含数据的定义和getter/setter方法，业务逻辑和应用逻辑都放在服务层中，这种类在Java中成为POJO。<br>
贫血模型：包含了一些业务逻辑，但不包含依赖持久层的业务逻辑，依赖于持久层的逻辑或放在服务层中。<br>
充血模型：包含了所有的业务逻辑，包括依赖于持久层的业务逻辑

#### 18. 秒杀系统设计要点？
- 数据预热<br>
数据预加载到缓存
- 缓存<br>
CDN缓存、数据缓存
- 解决超卖<br>
引入MQ，串行化操作库存
- 流量削峰<br>
引入MQ
- 熔断限流<br>
熔断，优先保证主要的业务。限流，识别异常流量，进行封锁。允许部分请求失败。
- 弹性扩容<br>
增加服务节点










#### 100. question 100

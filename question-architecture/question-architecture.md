# question-architecture
some questions and answers for architecture.

#### 1. CDN缓存图片、js等静态资源？？？
Content Delivery Network，内容分发网络。<br>
其基本思路是尽可能避开互联网有可能影响数据传输和稳定性的瓶颈和环境，使内容传输更稳定更快。

#### 2. 什么是缓存雪崩？如何避免？
数据未加载到缓存中，或者是缓存在同一时间大面积失效，导致获取查询请求到数据库，数据库CPU或内存负载过高。<br>

解决思路：<br>
(1) 加锁计数，或者设置合理的队列数来避免缓存失效时对数据库造成太大压力，但这样会降低系统的吞吐量。<br>
(2) 分析用户行为，让失效时间点均匀分布。<br>
(3) 缓存服务器备份。

#### 3. 什么是缓存穿透？如何解决？布隆过滤器原理？？？
恶意请求缓存中不存在的数据，导致所有请求落在数据库上，造成数据库压力过大而崩溃。<br>
常见的解决办法是采用布隆过滤器。将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被这个bitmap拦截，从而避免对底层数据库的查询压力。<br>
另外一种简单的办法：即使查询结果为空，也进行缓存，但设置较短的过期时间。

#### 4. 什么是缓存击穿？如何解决？
某个热点key对应的缓存数据过期的瞬间，解决方式有两种：<br>
(1) 互斥锁<br>
缓存过期后，程序去更新缓存前，先获取锁，获取到锁的线程才能更新，没有获取到锁的线程休眠一段时间后再次尝试获取缓存。<br>
同一时刻只有一个线程去读数据库，避免大量数据库请求对数据库的冲击。<br>
比如Redis，可以用SETNX命令对key加锁。
```java
public String get(String key) {
    String value = redis.get(key);
    if (value == null) { // 缓存过期
        if (redis.getnx(key_mutex, 1, 1 ** 60) == 1) { // 获取到锁，从数据库读取数据，更新缓存
            value = db.get(key);
            redis.set(key, value, expire_time);
            redis.del(key_mutex);
        } else { // 没有获取到锁，休眠后再次获取缓存
            sleep(50);
            redis.get(value);
        }
    } else {
        return value;
    }
}
```
(2) 设置热点缓存数据永不过期

#### 4. 如何提高缓存的命中率？
缓存的命中率越高，说明缓存的效益越高，应用的性能越好，抗并发的能力越强。<br>
(1) 缓存的粒度越小，命中率越高<br>
(2) 数据变化时，直接更新缓存，比移除缓存命中率更高<br>
(3) 合理利用有限的容量，减少失效和淘汰（大多数采用LRU算法）<br>
(4) 缓存预加载<br>

#### 5. 负载均衡实现算法？
随机（random）（加权随机）<br>
轮询（round-robin）（加权轮询）<br>
一致哈希（consistent-hash）<br>
主备（master-slave）<br>
最少连接（least connection）<br>

##### 一致哈希
将[0, 2^32)所有整数投射到一个圆上，然后将负载机的唯一标识（比如ip）通过hash运算得到的整数也投射到这个圆上，server-A，server-B，请求到达后，将请求的唯一标识（比如用户id）通过hash运算得到的整数也投射到这个圆上，顺时针找到第一个负载机。<br>

一致哈希解决了两个问题：<br>
散列的不变性：同一个用户的请求尽量落到同一台负载机上。<br>
异常以后的分散性：某台负载机挂掉后，原来落到这台的请求尽量分散到其他负载机，对系统的冲击最小。<br>

一致哈希可用于分配cache服务，将同一用户的数据缓存到固定的服务器上，不用多台服务器缓存重复的数据，能提高缓存的利用率。<br>
但这样也有弊端，当某台服务器挂掉，请求落到其他服务器，而其他服务器上没有对应的缓存，可能会使数据库压力骤增。

具有较好的容错性和扩展性。<br>
改进：虚拟节点。<br>
服务节点较少时，可能出现分布不均匀，可以对每个节点都计算一个虚拟节点。

##### 主备算法
尽量将请求分配到某台固定的服务器上，其他服务器做备份，固定的服务器出现问题后再切换到备份的服务器。<br>
应用：Message Queue消息队列，为保证时效性，尽量将所有请求都放到同一台服务器上。

##### 最少连接
根据节点的真实负载，动态的调整节点的权重。（最小响应时间，最小活跃数）<br>

#### 6. 负载均衡分类？
- 二层负载均衡<br>
负载均衡服务器对外提供一个VIP（虚IP），集群中不同机器使用相同IP，不同MAC。负载均衡服务器接收到请求后，根据改写报文的目标MAC的方式将请求转发到目标服务器。
- 三层负载均衡<br>
和二层类似，负载均衡服务器对提供一个虚IP，但集群中不同机器使用不同IP。接收到请求后，根据不同的负载均衡算法，通过IP将不同的请求转发的目标服务器。
- 四层负载均衡<br>
工作在OSI模型的传输层，只有TCP/UDP协议，这两种协议包含源IP、目标IP、源端口、目标端口。接收到请求后，通过修改数据包的地址（IP+端口号）将流量转发到应用服务器。
- 七层负载均衡<br>
工作在OSI模型的应用层，有较多协议，常用HTTP，Redius、DNS等。可根据七层的URL、浏览器类别、语言决定是否进行负载均衡。

#### 7. 常用负载均衡工具？
LVS，Nginx，HAProxy<br>
- LVS（Linux Vitrual Server）<br>
Linux虚拟服务器，通过LVS提供的负载均衡技术和Linux操作系统实现一个高性能、高可用的服务器集群。<br>
LVS主要用来做四层负载均衡，服务器集群系统由三部分组成：最前端的负载均衡层（Load Balancer）、中间的服务器群组层，用Server Array表示、最底层的数据共享存储层，用Shared Storage表示。<br>
在用户看来所有的应用都是透明的，用户只是在使用一个虚拟服务器提供的高性能服务。
- Nginx<br>
主要用来做七层负载均衡。
- HAProxy<br>
提供高可用、负载均衡以及基于TCP和HTTP应用的代理，支持虚拟主机，是免费、快速、可靠的解决方案，特别适用于负载大的web站点。

#### 8. 正向代理和反向代理？
正向代理：<br>
A想访问C，但无法直接访问，那么A访问B，B再访问C，那么A就能访问C，但C并不知道被谁访问。比如google无法访问，但搭建在国外的B可以访问，那么让他去请求google再把内容返回给A。<br>

反向代理：<br>
A访问baidu，baidu背后有很多台服务器，A并不知道是哪台提供的服务，只需要知道代理服务器是baidu就好了，反向代理服务器会将请求发给真实的服务器，主要是实现负载均衡。

#### 8. 短链接（网址）设计？？？question-java-web-005
通过发号策略，对每一个长地址发一个号，小型系统可以直接用MySQL的自增索引，大型应用可以采用分布式key-value系统做发号器，将得到的10进制的号转化为62进制（26个大写字母+26个小写字母+10个数字）。

对于同一个长地址，多次请求会生成不同的短地址，可以采用key-value（key是长地址，value是短地址）存储最近生成的记录，采用过期淘汰机制。

发号器可以拆分成多个，比如拆成两个，生成单双号，拆成10个，生成0~9。

跳转用301还是302？<br>
301是永久重定向，302是临时重定向。<br>
301比较符合HTTP语义，但无法统计到短地址的点击次数，选用302能有助于数据分析。

#### 10. 集群服务器（分布式系统）如何同步session？
(1) session复制<br>
多台服务器之间相互复制，每一台服务器都保存了所有的session。<br>
仅适用于小型集群。<br>
基于Resin/Tomcat，web容器本身的session复制机制。<br>
(2) session绑定<br>
利用负载均衡的客户端地址hash算法，同一个客户端的请求转发到同一台服务器上。<br>
某一台服务器故障会导致这部分的session丢失。<br>
(3) 利用cookie记录session<br>
将session加密后存储在cookie中，接收到请求时从cookie中获取session进行解密。<br>
有被破解的危险；<br>
用户可能禁用cookie。<br>
(4) session服务器<br>
统一管理session。<br>
基于数据库的session共享；<br>
基于OsCache/Redis/Memcached进行session共享

#### 11. 什么是分布式事务？？？
涉及到操作多个数据库的事务，保证分布式系统的数据一致性。<br>
处理的关键在于有一种机制可以知道事务在任何地方所做的所有操作，提交或回滚的决定必须产生统一的结果，都提交或都回滚。<br>

两阶段提交（强一致性）：备阶段（投票）、提交阶段（执行）<br>
三阶段提交（强一致性）：try、confirm、cancel<br>
消息中间件（最终一致性）：本地消息、MQ中间件消息<br>

JTA（Java Transaction API）：分布式事务

注：<br>
强一致性：数据更新后，任意时刻所有副本中的数据都是一致的，一般采用同步的方式实现。<br>
弱一致性：数据更新后，不承诺可以立即读到最新写入的值，也不承诺多久之后可以读到。<br>
最终一致性：弱一致性的一种形式，保证最终会返回上一次更新操作的值。<br>

#### 12. 分布式事务解决方案？
##### 两阶段提交（2PC）
第一阶段：事务协调器要求每个涉及到事务的数据库预提交（precommit）此操作，并反映是否可以提交<br>
第二阶段：事务协调器要求每个数据库提交数据<br>
如果有任何一个数据库否决此次提交，则所有数据库都回滚。<br>
牺牲了一部分可用性来换取一致性。<br>

优点：尽量保证了数据的强一致性，适合对强一致性要求高的关键领域<br>
缺点：实现复杂，牺牲了可用性，对性能影响较大，不适合高并发场景<br>

(1) 单点问题：事务协调器<br>
(2) 同步阻塞：准备就绪后数据库资源阻塞<br>
(3) 数据不一致：网络问题，没有所有数据库都接收到commit通知，造成不一致<br>

##### 补偿事务（TCC）三阶段提交
针对每个操作，都要注册一个与其对应的确认和补偿（撤销）操作，分为三个阶段：<br>
(1) try阶段：对业务系统做检测及资源预留<br>
(2) confirm阶段：对业务系统做确认提交，try阶段执行成功并开始执行confirm阶段时，默认confirm阶段不会出错，即try成功，confirm一定成功<br>
(3) cancel阶段：业务执行错误，需要回滚的状态下执行的业务取消，预留资源释放<br>

优点：和2PC相比，实现以及流程相对简单，但数据的一致性比2PC要差一些<br>
缺点：应用层的补偿，需要写补偿的代码，在一些场景中可能不好定义<br>

##### 本地消息表
将需要分布式处理的任务通过消息日志的方式异步执行，消息日志可以存储到本地文件、数据库或消息队列，再通过业务规则自动或人工发起重试。

##### MQ事务消息
将本地消息表移动到MQ中间件中。

##### Sagas事务模型

##### 尽最大努力通知

#### 12. 分布式、高并发、多线程的区别？
分布式是一个概念，是为了解决单个物理服务器容量和性能瓶颈问题而采用的优化手段，包括分布式文件系统、分布式缓存、分布式数据库、分布式计算。<br>
分布式的实现有两种方式：<br>
(1) 水平扩展：通过添加服务器的方式，将流量分到多个服务器上<br>
(2) 垂直拆分：将业务拆分到不同的服务器上<br>

高并发从业务角度去描述系统的能力，要解决的问题是访问量，可以通过分布式的技术去解决，此外还有其他优化手段：缓存系统、CDN、多线程。<br>

多线程是指从软件或硬件上实现多个线程并发执行的技术，更多的是解决CPU调度多个进程的问题，从而让这些进程看上去是同时执行的。

#### 13. 分布式架构设计中的CAP理论？
- 数据一致性（Consistency）：所有节点在同一时间具有相同的数据
- 可用性（Availability）：保证对于每个请求成功或失败都有响应
- 分区容错性（Partition Tolerance）：系统中信息的丢失或失败不影响系统的运行

CAP定理：在一个分布式系统构建中，不可能同时满足一致性、可用性和分区容错性三个需求，最多只能同时满足两个<br>
分布式系统中一般要求某个节点挂掉之后系统整体可以继续提供服务，即分区容错性，所以一般是保证P，在C和A之间做取舍。

- 强一致性：ACID
- 分布式一致性：CAP
- 弱一致性（最终一致性）：BASE

#### 14. 分布式BASE理论？
部分业务可以容忍一定程度的延迟一致，为了兼顾效率，发展出最终一致性理论BASE。<br>
BASE理论是对CAP中一致性（C）和可用性（A）权衡的结果。<br>
- 基本可用（Basically Available）：分布式系统在故障的时候，允许损失部分可用性，保证核心可用
- 软状态（Soft State）：系统存在中间状态，允许不同节点间副本同步的延迟
- 最终一致性（Eventual Consistency）：所有副本经过一定时间后，最终能够达到一致的状态

#### 15. 分布式系统全局ID生成方案？
分布式全局ID需满足的条件：
- 全局唯一：基本要求
- 高性能：
- 高可用：
- 易接入：
- 趋势递增：看业务需求，不严格要求

(1) UUID<br>
优点：性能高<br>
缺点：无法递增；占用空间大；不可读<br>
(2) Twitter的snowflake算法<br>
优点：简单高效；能递增<br>
缺点：依赖机器的时钟，时钟回拨会生成重复的ID；分布式环境时钟不同步导致不是递增<br>
(3) 数据库自增ID<br>
优点：简单，天然递增<br>
缺点：数据迁移、分离、合并困难；性能瓶颈；单点故障<br>
改进：数据库集群，设置不同的增长步长<br>
(4) Redis<br>
INCR命令，原子操作，单线程不会存在重复<br>
优点：性能优于数据库<br>
缺点：需要编码和配置，增加系统复杂度<br>
(5) Zookeeper<br>
比较少用

#### 16. 分布式锁？
分布式锁的要求：
- 互斥性
- 可重入性
- 不会死锁
- 阻塞锁
- 高可用

三种实现方式：
- （乐观锁）基于版本号和CAS实现，与存放版本号的存储无关
- （悲观锁）数据库锁<br>
数据库表记录锁住的方法或资源
- （悲观锁）基于Redis的分布式锁
setnx函数（set if not exist）<br>
轮询机制，锁释放后可能多个竞争，某些任务可能饿死
- （悲观锁）基于ZooKeeper的分布式锁<br>
基于临时有序节点，客户端对资源加锁时，在zookeeper上与该资源对应的指定节点的目录下，生成一个唯一的瞬时有序节点。有序节点中序号最小的一个获得锁。释放锁时删除节点。<br>

Zookeeper四种类型节点：<br>
(1) 持久性节点<br>
(2) 持久性顺序节点<br>
(3) 临时性节点<br>
(4) 临时性顺序节点<br>

持久性：创建了节点后，不管客户端是否断开连接，Zookeeper服务端都会记录这个节点<br>
临时性：客户端断开了连接，Zookeeper服务端不再保存这个节点<br>
顺序性：创建节点的时候，Zookeeper自动给节点编号<br>

Zookeeper监听机制：客户端注册监听关心的目录节点，当目录节点发生变化（数据改变、被删除、子目录节点增加删除等），Zookeeper会通知客户端。<br>
一个线程创建了一个节点后，相当于获取了锁，其他线程去创建同样的节点，会失败，相当于不能获取到锁，只能监听这个节点的变化。<br>

获取到锁的线程处理完业务后，删除了节点，其他线程会收到通知，去创建同样的节点。<br>
使用临时性节点，如果创建了节点的客户端有异常，断开连接，节点会自动删除，避免死锁。<br>

节点删除后的惊群效应：多个其他线程竞争。可以使用临时顺序节点，比如表示锁的节点是/lock，在该节点下创建临时顺序性节点，如/lock/001, /lock/002, /lock/003，相当于设置了获取锁的顺序。<br>

#### 17. 领域驱动设计？充血模型？贫血模型？
Domain-Driven Design，简称DDD。<br>

分为四层：<br>
用户界面层：向用户展示信息<br>
应用层：没有业务逻辑，为程序提供任务处理<br>
领域层：业务的核心，存储领域模型的状态<br>
基础设施层：为其他层提供底层依赖<br>

领域模型对象只是用来存储应用的数据，使用了贫血模型这种反模式。<br>
失血模型：模型仅包含数据的定义和getter/setter方法，业务逻辑和应用逻辑都放在服务层中，这种类在Java中成为POJO。<br>
贫血模型：包含了一些业务逻辑，但不包含依赖持久层的业务逻辑，依赖于持久层的逻辑或放在服务层中。<br>
充血模型：包含了所有的业务逻辑，包括依赖于持久层的业务逻辑

领域驱动设计：划分界限上下文<br>
微服务架构：划分服务模块

#### 18. 秒杀系统设计要点？
- 数据预热<br>
数据预加载到缓存
- 缓存<br>
CDN缓存、数据缓存
- 解决超卖<br>
引入MQ，串行化操作库存
- 流量削峰<br>
引入MQ
- 熔断、限流<br>
熔断，优先保证主要的业务。<br>
限流，识别异常流量，进行封锁。<br>
允许部分请求失败。
- 弹性扩容<br>
增加服务节点

#### 20. 限流算法？
- 漏桶算法（队列）<br>
将流量放入桶中，漏桶同时也按照一定的速率流出，如果流量过快的话就会溢出，溢出的流量直接丢弃。<br>
比较简单粗暴，不能应对突然暴增的流量。

- 令牌桶算法<br>
以一个恒定的速率向固定容量的桶中放入令牌，当有请求来时则取走一个或多个令牌。当桶中没有令牌则将当前请求丢弃或者阻塞。<br>
比如控制并发QPS为100，则每10ms放入一个令牌。<br>
可以应对一定的突发流量。

#### 21. 如何保证缓存和数据库的双写一致性？
Cache Aside Pattern<br>
读：先读缓存，缓存没有的话则读数据库，然后放入缓存中，同时返回响应。<br>
写：先更新数据库，再删除缓存。<br>
删除缓存or更新缓存：如果更新的逻辑笔记复杂，一般选择删除。<br>

缓存和数据库不一致的问题：<br>
(1) 修改数据库成功，删除缓存失败，导致数据库中的数据是新的，缓存中的数据是旧的。<br>
解决：先删除缓存，再更新数据库。如果数据库修改失败，则数据库的数据是旧的，缓存是空的，读的时候会将旧的数据写入缓存，不存在不一致的问题。<br>
(2) 并发下的问题：第一个请求删除了缓存，还没更新数据库，第二个请求查询到旧的数据，写入到缓存中，第一个请求再更新数据库，导致数据库的数据是新的，缓存的数据是旧的。<br>
解决：对于同一条数据的操作，根据唯一标识将操作放入到内部队列中。多个更新缓存的请求可以合并为一个。

#### 22. 分布式服务的幂等性设计？

#### 23. 中台
技术中台：技术平台，比如微服务开发框架、devops平台、paas平台、容器云
业务中台：微服务业务平台，比如用户中心、订单中心
组织中台：企业内部资源调度中心和内部创新孵化组织

前台：用户触点，企业的最终用户直接使用或交互的系统，是企业与最终用户的交点，比如网站、手机APP、微信公众号
后台：管理企业的一类核心资源，实现后端资源的信息化管理，比如财务系统、产品系统、仓储系统，也包括基础设施和计算平台。

后台不能很好的支撑前台快速响应用户的需求，后台更多的是解决管理效率的问题，而中台要解决的才是前台创新的问题。

中台是真正为前台而生的平台，可以是技术平台、业务能力，甚至是组织机构
更好的服务前台规模化创新，更好的响应服务引领用户，是企业真正做到自身能力与用户需求的持续对接
可以将前台系统中稳定通用的业务能力沉降到中台，恢复前台的响应力
可以将后台中需要频繁变化或者是需要直接被前台使用的业务能力提取到中台，赋予这些业务能力更强的灵活度和更低的变更成本。





#### 100. question 100

# question-architecture-mq
some questions and answers for Message Queue, like RabbitMQ, ActiveMQ, Kafka and so on.

#### 1. 消息中间件有哪些优点？
优点：<br>
- 系统解耦<br>
消息队列要解决的最本质问题。
- 异步调用<br>
提高系统性能
- 流量削峰
- 最终一致性<br>
不是消息队列的必备特性，但是可以通过消息队列来实现
- 广播

**RabbitMQ**：支撑高并发、高吞吐量、性能很高、有完善的后台管理界面，另外还支持集群化、高可用部署架构、消息高可靠支持，功能比较完善；社区活跃、版本迭代频繁。<br>
缺点：基于erlang开发，难分析源码或二次开发。<br>
**RocketMQ**：阿里开源的，经过阿里的生产环境的超高并发、高吞吐量的考验，性能卓越，支持分布式事务等特殊场景。<br>
基于Java语言开发，适合阅读源码，进行二次开发。<br>
**ActiveMQ**：老牌的消息中间件，比较成熟，但性能较差，迭代慢<br>
**Kafka**：功能比较少，优势在于专为超高吞吐量的实时日志采集、实时数据同步、实时数据计算等场景设计。因此在大数据领域中配合实时计算技术（Spark Streaming, Storm, Flink）使用的比较多。

特性 | ActiveMQ | RabbitMQ | RocketMQ | Kafka
-|-|-|-|-
开发语言 | Java | Erlang | Java | Scala
单机吞吐量 | 万级 | 万级 | 十万级 | 十万级
时效性 | ms级 | us级 | ms级 | ms级以内
可用性 | 高（主从架构） | 高（主从架构） | 非常高（分布式架构） | 非常高（分布式架构）
功能特性 | 成熟的产品，在很多公司得到应用；<br>有较多的文档；<br>各种协议支持较好 | 基于erlang开发，并发能力很强，性能极好，延时很低；<br>管理界面比较丰富 | MQ功能比较完备，扩展性好 | 只支持主要的MQ功能；为大数据准备，在大数据领域应用较广

#### 2. 系统架构引入消息中间件的缺点？
- 系统可用性降低<br>
解决：集群
- 系统稳定性降低<br>
重复消费：全局唯一ID<br>
消息丢失：生产者丢失（MQ事务回滚）、消费者丢失（修改自动确认为手动确认）<br>
消息顺序正确性<br>
- 分布式一致性问题（消息没有被消费）

#### 3. 两种消息队列协议？
项 | JMS (Java Message Service) | AMQP (Advanced Message Queuing Protocol)
-| - | -
定义 | Java API | 协议
跨语言 | 否 | 是
跨平台 | 否 | 是
支持消息模型 | 两种消息模型：<br>(1)Peer-to-Peer<br>(2)Pub/sub | 五种消息模型：
支持消息类型 | 多种消息类型：<br>StreamMessage<br>MapMessage<br>TextMessage<br>ObjectMessage<br>BytesMessage | 二进制

AMQP协议定义了publisher consumer exchange queue
RabbitMQ是AMQP协议的一种实现。

#### 4. 如何保证消息的有序性？
消费者内部用队列实现
对消息进行编号，消费者根据编号判断
业务逻辑中自己实现？

#### 5. 如何实现消息的重发？
消息重发是指消费者在消费异常时，消费者将消息重新放入队列下次处理。超过重试次数后会放入一个特殊队列Dead Letter Queue中。

#### 6. 如何避免消息重复消费？如何实现幂等？
消息编号、保存消费记录

#### 7. 如何利用消息队列实现最终一致性？

#### 8. RabbitMQ的基本概念？
生产者、
生产者发送一个消息，需要指定交换器名称、路由键、消息内容、额外参数
交换器名称指定消息要发送到哪个交换器
路由键用于交换器如何路由该消息到队列
消息内容是字节流
额外参数：是否需要持久化，contentType，存活时间

消费者、

交换器
消息路由，决定如何将消息传递到队列或其他交换器
一个交换器的组成：名称、路由方式
四种路由方式：直接路由direct、广播路由fanout、话题路由topic、header
默认交换器：名称为空字符串，路由方式为直接路由
定时交换器时可以指定候补交换器，指定是否持久化、是否自动删除

队列
存放消息的容器
消息存活时间，取决于队列设定和消息自身设定的最小值
队列和消息都可以持久化
队列可以设定最大长度和最大容量，超出时可舍弃即将入队的消息或最早的消息
队列可以设定消息优先级

路由绑定
将一个队列绑定/解绑到另一个交换器
将一个交换器绑定/解绑到另一个交换器

死信
(1) 被消费者拒绝
(2) 队列长度超出限制后被舍弃
(3) 消息超时
队列可以设置消息成为死信后的处理方式：
x-dead-letter-exchange：死信投入到交换器
x-dead-letter-routing-key：死信投入到死信交换器的路由键

生产消息确认机制
中间件通知生产者消息已被记录，是一个异步确认过程

事务性消息发布
与消息确认互斥

消费者两种获取消息的模式：push、pull

消费消息确认机制：autoAck
true：消息在接收时直接自动返回确认
false：程序在消息处理完后手动返回确认

push：
消费者有未确认的消息时，队列不会再推送消息给消费者
消费者可以设置perfetch参数，设置自身同时处理消息的最大数量

多个消费者订阅同一个队列，以轮询的方式发送消息给消费者

消息确认机制和事务性消息发布会降低吞吐量

exchange、queue、message均可以持久化到磁盘

集群：
每一个节点都保存了所有的exchange和queue
每个队列的消息仅保存在一个节点
可以为节点上的队列设置镜像，对于每个队列来说，其中一个节点上的是master，其他的是slave











#### 100. question 100

# question-http
some codes and questions of http.

#### 1. HTTP常见状态码？
状态码 | 说明
-|-
100~199 | 成功接收请求，需要客户端继续提交下一次请求才能完成整个处理过程
200~299 | 成功接收请求并已完成整个处理过程
300~399 | 为完成请求，客户端需进一步细化需求，例如：<br>请求的资源已移到一个新的地址，请重定向（302、307）<br>从缓存获取资源（304）
400~499 | 客户端错误，包含语法错误或者不能正确执行<br>请求的资源不存在（404）<br>权限不足（403）
500~599 | 服务器错误
100 | （继续）请求者应当继续提出请求，100表示服务器已接收到请求的第一部分，正在等待其他部分
101 | （切换协议）请求者要求服务器切换协议（HTTP以外的协议？？？），服务器已确认并准备切换
200 | 一切正常
201 | （已创建）请求成功，且服务器已创建新的资源
202 | （已接受）服务器已接受请求，但未处理
204 | （无内容）服务器成功处理了请求，但无返回内容
206 | 客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源
301 | （永久重定向）
302/307 | （临时重定向）请求的资源已被移动到别处，新的地址在header的location给出。307强制要求使用POST方法
304 | （未修改）使用客户端缓存
401 | （未授权）请求要求身份验证
403 | （禁止）服务器拒绝处理，通常用于服务器上文件或目录的权限设置
404 | （找不到）服务器上不存在客户端请求的资源
405 | （方法禁用）禁用请求中的方法
500 | （服务器内部错误）无法完成请求
502 | （错误网关）服务器作为网关或代理服务器，从上游服务器接收到无效响应
503 | （服务器正忙）
504 | （网关超时）服务器作为网关或代理服务器，没有及时从上游服务器接收到响应

301表示永久重定向，302表示临时重定向，为什么要使用301不使用302？<br>
因为302存在网址URL劫持。假如A的地址很短，对用户友好，302重定向到B，url很长，由于浏览器并不能总是抓取目标地址，Google可能仍显示A的地址，但显示B的内容，这种就是网址URL劫持。<br>
301永久重定向则不会出现这种情况。

#### 2. HTTP版本1.0和1.1和2.0的区别？
项 | 1.0 | 1.1 | 2.0
-|-|-|-
建立连接 | 一次请求一个连接 | 一个连接可以发送多个请求和响应，多个请求可以重叠和同时进行（管线化） | /
长短连接 | 短连接 | 默认长连接 | /
Host字段 | 没有Host字段 | 必须有Host字段 | /
ETag头 | 没有 | 新引入 | /
Cache-Control头 | 没有 | 新引入 | /
状态码 | 16个 | 引入warning头域，新增24个状态码 | /
断点续传 | / | 支持断点续传？？？ | /

#### 3. HTTP请求方法？
GET：请求指定页面的信息，并返回实体主体。<br>
HEAD：类似于GET，但返回的响应没有具体的内容，用于获取报头。<br>
POST：向指定资源提交数据请求处理（如表单、文件上传），数据被包含在请求体中。<br>
&emsp;可能导致新资源的建立或已有资源的修改。<br>
&emsp;在Request-URI所标识的资源后附加新的数据。<br>
PUT：请求服务器存储一个资源，并用Request-URI作为其标识<br>
DELETE：请求服务器删除指定的资源<br>
CONNECT：HTTP/1.1协议中预留给能够将连接方式改为管道的代理服务器<br>
OPTIONS：允许客户端查看服务器的性能<br>
TRACE：回显服务器收到的请求，主要用于测试或诊断<br>

#### 4.HTTP为什么要三次握手和四次握手？
&emsp;&emsp;如果只有两次握手，客户端发送的一个报文因为延时，长时间没有到达服务器，客户端也没有得到来自服务器的确认，就把这个报文认定为“已失效”，并且重新发送一个报文。<br>
&emsp;&emsp;如果认定失效后，这个失效的报文又通过阻塞送到了服务器，因为只有两次握手，连接就建立起来了，但这个连接是错误的，因为正确的报文已经重新发出了。<br>
&emsp;&emsp;如果有三次握手，服务器接收到报文再返回给客户端确认时，客户端校验ack不正确，则会忽略由失效报文建立起来的连接。<br>
&emsp;&emsp;客户端没有内容发送个服务器了，就会发送FIN报文，但服务器接收到FIN报文后未必会马上关闭socket连接，因为服务器可能还有一些信息要发送给客户端，但还没有发完。<br>
&emsp;&emsp;服务器发送FIN报文和客户端是分开的，于是就有了四次握手。<br>

#### 5. 顶级域名？一级域名？二级域名？？？
顶级域名：.com<br>
一级域名：baidu.com<br>
二级域名：www.baidu.com

#### 6. HTTP长连接和短连接的区别？
&emsp;&emsp;在HTTP 1.0中，默认使用的是短连接，客户端和服务器每进行一次HTTP操作，都会建立一个连接，结束后会中断连接。例如，浏览器解析一个HTML文件的时候，如果包含css、js等外部资源，每遇到一个都会建立一次HTTP连接。<br>
&emsp;&emsp;在HTTP 1.1中，默认使用长连接，在响应头加入：Connection: keep-alive<br>
&emsp;&emsp;使用长连接时，客户端和服务器之间传输HTTP数据的连接不会关闭，如果客户端再次请求服务器的数据，会使用已经建立的连接。<br>
&emsp;&emsp;HTTP协议的长短连接，实际上是TCP协议的长短连接。<br>
&emsp;&emsp;keep-alive有一个保持的时间，可以在服务器上设置。

#### 7. HTTP和HTTPS的区别？
HTTPS是基于HTTP开发的，使用安全套接字层（SSL）进行信息交换，加密+认证+完整性保护。

项 | HTTP | HTTPS
-|-|-
端口 | 80 | 443
网络模型层 | 应用层 | 传输层
加密 | 不加密，可能被窃听 | 加密
验证身份 | 不验证身份，可能遭到伪装 | 验证身份
验证完整性 | 无法验证完整性，可能被篡改 | 验证完整性

#### 8. HTTP和webSocket的相同点和不同点？
HTTP | webSocket
-|-
/ | 都是基于TCP协议<br>都要经过request和response阶段<br>请求失败成功返回的状态码都一样
非持久化协议 | 持久化连接，真正的长链接
一个request只能有一个response，response是被动的，不能主动发起 | 实质的推送方式是服务器主动推送，只要有数据就推送到请求方

#### 9. HTTP请求和响应的报文格式？
请求报文包含三部分：<br>
请求行，包括请求方法、URI、HTTP版本<br>
请求首部<br>
请求实体<br>

响应报文包含三部分：<br>
状态行，包括HTTP版本、状态码、状态码的原因短语<br>
响应首部<br>
响应实体

#### 10. 常见的http首部字段？
通用首部字段<br>
Date：创建报文的时间<br>
Connection：连接的管理<br>
Cache-Control：缓存的控制<br>
Transfer-Encoding：报文主体的传输编码方式<br>

请求首部字段<br>
Host：请求资源所在的服务器，必需<br><br>
Accept：可处理的媒体类型<br>
Accept-Charset：可接收的字符集<br>
Accept-Encoding：可接收的内容编码<br>
Accept-Language：可接收的自然语言<br>
Authorization：证明客户端有权查看某个资源<br>
User-Agent：将客户端的操作系统、浏览器及其他信息告诉服务器，非必需<br>

响应首部字段<br>
Accept-Ranges：可接收的字节范围<br>
Location：令客户端重定向到的URI<br>
Server：http服务器的安装信息<br>

实体首部字段<br>
Allow：资源可支持的HTTP方法<br>
Content-Type：实体主类的类型<br>
Content-Encoding：实体主体适用的编码方式<br>
Content-Language：实体主体的自然语言<br>
Content-Length：实体主体的字节数<br>
Content-Range：实体主体的位置范围，一般用于发出部分请求时使用

#### 11. Windows、linux命令行发送HTTP请求？？？
Windows telnet

#### 12. 一次完整的HTTP请求经历的7个步骤？
(1) 建立TCP连接<br>
&emsp;&ensp;TCP协议和IP协议共同构建Internet，即著名的TCP/IP协议族。<br>
&emsp;&ensp;TCP协议是低层协议，HTTP是高层协议，必须先建立低层协议的连接，TCP协议使用的端口一般是80。<br>
(2) 客户端发送请求行<br>
&emsp;&ensp;例如：GET /index.html HTTP/1.1<br>
(3) 客户端发送请求头<br>
&emsp;&ensp;以头信息的形式向服务器发送其他信息，以空白行结束。<br>
(4) 服务器响应状态行<br>
&emsp;&ensp;例如：HTTP/1.1 200 OK<br>
(5) 服务器发送响应头<br>
&emsp;&ensp;和客户端类似，以空白行结束<br>
(6) 服务器发送响应实体<br>
&emsp;&ensp;以Content-Type响应头信息所描述的格式发送客户端实际需要的数据<br>
(7) 服务器关闭TCP连接<br>
&emsp;&ensp;请求结束后服务器关闭连接，如果客户端或服务器在头信息加入了Connection: keep-alive，TCP连接在发送后仍保持打开状态，客户端可以继续通过相同的连接发送请求。

#### 13. HTTP方法GET和POST的区别？
GET请求中只产生一个TCP数据包，浏览器将header和data一起发送出去，等待服务器响应。<br>
POST请求中会产生两个TCP数据包，浏览器先发送header，服务器响应100后，再发送data。

#### 14. HTTP 1.1的主要特性？
(1) 持久连接<br>
&emsp;&ensp;TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。客户端和服务器可以主动关闭连接，一般是客户端在发送最后一个请求时声明Connection: close，要求服务器关闭连接。<br>
&emsp;&ensp;浏览器一般支持同一个域名最大开6个持久连接。<br>
(2) 管道机制<br>
&emsp;&ensp;在同一个连接里面，客户端可以同时发送多个请求，Content-Length首部用于区分响应的数据包是哪一个请求的。<br>
(3) 分块传输编码（chunked transfer encoding）<br>
&emsp;&ensp;服务器不用等请求完成再发送所有数据，可以完成一部分就发送一个数据块。请求或响应头有Transfer-Encoding: chunked，表明响应由数量未定的数据块组成。<br>
&emsp;&ensp;每一个数据块前有一个十六进制的数表明长度，最后一个数据块的长度为0

#### 15. HTTP 2.0的主要特性？
(1) 多路复用。（HTTP 1.1的管道？？？）<br>
&emsp;&ensp;允许单一的http连接同时发送多个请求-响应消息，减少服务端的连接压力，内存占用更少，连接吞吐量更大；减少TCP慢启动，提高传输速度。<br>
&emsp;&ensp;HTTP底层依赖的是TCP协议，TCP连接相当于两根管道，一根从客户端到服务器，一根从服务器到客户端，管道里面的数据通过字节码传输，传输是有序的，每个字节都是一个一个传输的。<br>
&emsp;&ensp;客户端需要传输Hello和World两个单词，如果同时发送，服务端接收到的可能是HWeolrllod，如果同时将这些数据拆成包，给每个包加上标签，H①W②e①o②l①r②l①l②o①d，这样服务端也能将两个单词区分开来。<br>
&emsp;&ensp;二进制分帧层（Binary Framing）工作于应用层（HTTP 2.0）和传输层（TCP或UDP）之间，HTTP 2.0并没有修改TCP协议，而是尽可能利用其特性。<br>
&emsp;&ensp;在二进制分帧层中，HTTP 2.0对所有传输的数据都分割为帧，并对其进行二进制格式的编码，其中首部被封装到HEADER Frame，request body被封装到DATA Frame。<br>
&emsp;&ensp;HTTP 2.0的性能优化不在于高带宽，而是低延迟。TCP会随着时间进行自我调谐，起初会显示连接的最大速度，如果传输成功，会随着时间的推移提高传输速度，这种调谐称为TCP慢启动，让原本就有突发性和短时性的http连接变得低效。<br>
&emsp;&ensp;HTTP 2.0让所有数据流共用一个连接，可以更有效的利用TCP连接。<br>

(2) 首部压缩。<br>
&emsp;&ensp;HTTP请求和响应都是由状态行、消息头、消息主体三部分组成的，其中消息主体有经过压缩，但状态行和消息头是纯文本传输，随着web功能的越来越复杂，消息头消耗的流量越来越大，尤其是UserAgent，Cookie这些不常变化的头信息。

(3) 支持服务端推送。<br>
&emsp;&ensp;在浏览器明确的发送请求之前，服务器往往已经知道浏览器请求的网页的需要的附件资源，在响应浏览器第一个请求后，就可以开始推送这些资源。这样服务端可以充分利用网络空闲时间，提高页面加载效率。

Nginx 1.13.9版本开始支持服务器推送。
```
server {
    listen 433 ssl http2;
    server_name localhost;
    ......
    location / {
        root        /usr/share/nginx/html;
        index       index.html index.htm;
        http2_push  /style.css;          # 如果用户请求根路径/，就推送这两个文件            
        http2_push  /example.png;
    }
}
```

#### 16. HTTP方法和RESTful资源操作的对应？
GET：获取资源<br>
POST：创建资源<br>
PUT：更新资源（客户端提供更新后的完整的资源）<br>
PATCH：更新资源（客户端提供资源需要更新的属性）<br>
DELETE：删除资源

#### 17. HTTPS加密原理？
(1) client发起https连接请求<br>
(2) server返回证书<br>
(3) client验证证书，得到server的公钥<br>
(4) client随机生成对称加密的秘钥<br>
(5) client用server的公钥对上一步的秘钥加密，发送给server<br>
(6) server用私钥解密得到第4步的秘钥<br>
(7) client和server通过第4步生成的对称加密的秘钥进行传输<br>

#### 18. PUT和PATCH的区别？
都是更新，PUT是全量更新，PATCH是部分更新。

































#### 100.question 100
